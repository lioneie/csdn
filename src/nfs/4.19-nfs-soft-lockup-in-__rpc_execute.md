# 问题描述

在某个CPU#110上出现大量的软锁报错:
```sh
[4158131.484488] watchdog: BUG: soft lockup - CPU#110 stuck for 22s! [kworker/u257:2:236027]
[4158171.485473] watchdog: BUG: soft lockup - CPU#110 stuck for 22s! [kworker/u257:2:236027]
[4158199.486164] watchdog: BUG: soft lockup - CPU#110 stuck for 23s! [kworker/u257:2:236027]
```

# vmcore分析

```sh
crash> mod | grep nfs # 可以看出，使用的是nfsv3
ffffffffc0397000  nfs_acl                   16384  (not loaded)  [CONFIG_KALLSYMS]
ffffffffc03ef100  nfsv3                     49152  fs/nfs/nfsv3.ko.debug 
ffffffffc066dc80  nfs                      311296  fs/nfs/nfs.ko.debug
# 加载调试的ko
crash> mod -s sunrpc net/sunrpc/sunrpc.ko.debug
crash> mod -s nfs fs/nfs/nfs.ko.debug
crash> mod -s nfsv3 fs/nfs/nfsv3.ko.debug
# crash> mod -s nfsv4 fs/nfs/nfsv4.ko.debug
```

执行`echo 1 > /proc/sys/kernel/softlockup_panic`后导出的vmcore。

查看崩溃时的堆栈:
```sh
crash> bt
PID: 236027  TASK: ffff99b651d44680  CPU: 110  COMMAND: "kworker/u257:2"
 #0 [ffff9ab03eb83d50] machine_kexec at ffffffff8725a70e
 #1 [ffff9ab03eb83da8] __crash_kexec at ffffffff8735b001
 #2 [ffff9ab03eb83e68] panic at ffffffff872b310e
 #3 [ffff9ab03eb83ef0] watchdog_timer_fn at ffffffff8738f21b
 #4 [ffff9ab03eb83f20] __hrtimer_run_queues at ffffffff8733ae98
 #5 [ffff9ab03eb83f80] hrtimer_interrupt at ffffffff8733b615
 #6 [ffff9ab03eb83fd8] smp_apic_timer_interrupt at ffffffff87c025ba
 #7 [ffff9ab03eb83ff0] apic_timer_interrupt at ffffffff87c01b1f
--- <IRQ stack> ---
 #8 [ffffaa3eedaebd98] apic_timer_interrupt at ffffffff87c01b1f
    [exception RIP: __x86_indirect_thunk_r15+3]
    RIP: ffffffff87e031c3  RSP: ffffaa3eedaebe40  RFLAGS: 00000286
    RAX: 0000000000000005  RBX: ffff9a3319bd4a18  RCX: 0000000000000006
    RDX: 0000000000000000  RSI: 0000000000000000  RDI: ffff9a3319bd4a18
    RBP: ffff9ab0343e0400   R8: ffff9a7c2c187a40   R9: ffff9ab035efba60
    R10: ffffe1aa188d9600  R11: ffff9a89fa993440  R12: 0000000000000000
    R13: 0000000000000001  R14: ffffffffc1063860  R15: ffffffffc10597a0
    ORIG_RAX: ffffffffffffff13  CS: 0010  SS: 0018
 #9 [ffffaa3eedaebe40] __rpc_execute at ffffffffc1063f6f [sunrpc]
#10 [ffffaa3eedaebe98] process_one_work at ffffffff872d0915
#11 [ffffaa3eedaebed8] worker_thread at ffffffff872d0b80
#12 [ffffaa3eedaebf10] kthread at ffffffff872d72f3
#13 [ffffaa3eedaebf50] ret_from_fork at ffffffff87c00202
```

```sh
crash> dis -rl ffffffffc1063f6f
...
/usr/src/debug/kernel-4.19.90/linux-4.19.90-23.15.v2101.ky10.x86_64/net/sunrpc/sched.c: 783
0xffffffffc1063f67 <__rpc_execute+119>: mov    %rbx,%rdi
0xffffffffc1063f6a <__rpc_execute+122>: callq  0xffffffff87e031c0 <__x86_indirect_thunk_r15>
/usr/src/debug/kernel-4.19.90/linux-4.19.90-23.15.v2101.ky10.x86_64/./arch/x86/include/asm/bitops.h: 318
0xffffffffc1063f6f <__rpc_execute+127>: mov    0x30(%rbx),%rax
```

可以看出`__x86_indirect_thunk_r15+3`是执行到`__rpc_execute()`的`do_action(task)`。

# 代码分析

整理了日志中堆栈的代码流程:
```c
__rpc_execute
  call_transmit
    xprt_transmit
      xs_tcp_send_request
        xs_sendpages
          xs_send_kvec
            sock_sendmsg
              tcp_sendmsg
                tcp_sendmsg_locked
                  sk_stream_alloc_skb
                    __kfree_skb
                      kfree
                release_sock
                  tcp_release_cb
        xs_nospace
          spin_unlock_bh
            raw_spin_unlock_bh
              _raw_spin_unlock_bh
                __raw_spin_unlock_bh
                  __local_bh_enable_ip
                    do_softirq
          xs_tcp_write_space
    xprt_prepare_transmit
      spin_unlock_bh
        raw_spin_unlock_bh
          _raw_spin_unlock_bh
            __raw_spin_unlock_bh
              __local_bh_enable_ip
                do_softirq
  __x86_indirect_thunk_r15+0x3/0x11
  __x86_indirect_thunk_rax+0x3/0x20
  __x86_indirect_thunk_rcx+0x3/0x20
  __x86_indirect_thunk_r15+0x0/0x11
```

# 补丁分析

`ed0172af5d6f SUNRPC: Fix a race to wake a sync task`:
```
我们观察到，NFS 客户端在 __rpc_execute 中的同步任务在等待 RPC_TASK_QUEUED 时没有响应来自 rpc_make_runnable() 的唤醒。 我怀疑这个问题通常不会被注意到，因为在一个忙碌的客户端上，任务最终会通过另一个任务完成或 xprt 事件重新被唤醒。然而，如果状态管理器正在清空插槽表，一个没有被唤醒的同步任务可能会导致客户端挂起。

我们已经能够证明，rpc_make_runnable() 中的唤醒操作会成功调用 wake_up_bit()（即没有竞争条件影响 tk_runstate），但 wake_up_bit() 的调用没有唤醒等待者。我怀疑唤醒者缺少对位的 wait_queue_head 的加载，所以 waitqueue_active() 返回 false。在 wake_up_bit()、prepare_to_wait() 和 waitqueue_active() 之上有一些非常有用的注释，帮助说明了这个问题。

通过在 wake_up_bit() 之前插入 smp_mb__after_atomic()，来解决这个问题，这样可以与 prepare_to_wait() 调用的 set_current_state() 成对使用。
```
