# 问题描述

在某个CPU#110上出现大量的软锁报错:
```sh
[4158131.484488] watchdog: BUG: soft lockup - CPU#110 stuck for 22s! [kworker/u257:2:236027]
[4158171.485473] watchdog: BUG: soft lockup - CPU#110 stuck for 22s! [kworker/u257:2:236027]
[4158199.486164] watchdog: BUG: soft lockup - CPU#110 stuck for 23s! [kworker/u257:2:236027]
```

# 代码分析

```c
__rpc_execute
  call_transmit
    xprt_transmit
      xs_tcp_send_request
        xs_sendpages
          xs_send_kvec
            sock_sendmsg
              tcp_sendmsg
                tcp_sendmsg_locked
                  sk_stream_alloc_skb
                    __kfree_skb
                      kfree
                release_sock
                  tcp_release_cb
        xs_nospace
          spin_unlock_bh
            raw_spin_unlock_bh
              _raw_spin_unlock_bh
                __raw_spin_unlock_bh
                  __local_bh_enable_ip
                    do_softirq
          xs_tcp_write_space
    xprt_prepare_transmit
      spin_unlock_bh
        raw_spin_unlock_bh
          _raw_spin_unlock_bh
            __raw_spin_unlock_bh
              __local_bh_enable_ip
                do_softirq
  __x86_indirect_thunk_r15+0x3/0x11
  __x86_indirect_thunk_rax+0x3/0x20
  __x86_indirect_thunk_rcx+0x3/0x20
  __x86_indirect_thunk_r15+0x0/0x11
```

# 补丁分析

`ed0172af5d6f SUNRPC: Fix a race to wake a sync task`:
```
我们观察到，NFS 客户端在 __rpc_execute 中的同步任务在等待 RPC_TASK_QUEUED 时没有响应来自 rpc_make_runnable() 的唤醒。 我怀疑这个问题通常不会被注意到，因为在一个忙碌的客户端上，任务最终会通过另一个任务完成或 xprt 事件重新被唤醒。然而，如果状态管理器正在清空插槽表，一个没有被唤醒的同步任务可能会导致客户端挂起。

我们已经能够证明，rpc_make_runnable() 中的唤醒操作会成功调用 wake_up_bit()（即没有竞争条件影响 tk_runstate），但 wake_up_bit() 的调用没有唤醒等待者。我怀疑唤醒者缺少对位的 wait_queue_head 的加载，所以 waitqueue_active() 返回 false。在 wake_up_bit()、prepare_to_wait() 和 waitqueue_active() 之上有一些非常有用的注释，帮助说明了这个问题。

通过在 wake_up_bit() 之前插入 smp_mb__after_atomic()，来解决这个问题，这样可以与 prepare_to_wait() 调用的 set_current_state() 成对使用。
```
